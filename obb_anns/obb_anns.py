"""Oriented Bounding Box Annotations.

Provides a toolkit to work with oriented bounding box ann_info.

Author:
    Yvan Satyawan <y_satyawan@hotmail.com>

Created on:
    February 19, 2020
"""
import json
from time import time
import numpy as np
import os.path as osp
from PIL import Image, ImageColor, ImageDraw, ImageFont
import colorcet as cc


class OBBAnns:
    def __init__(self,
                 ann_file):
        """Toolkit to work with Oriented Bounding Boxes.

        Workflow is generally to initialize the class, load ann_info, run the
        training loop, then load proposals generated by the network, and finally
        to calculate the various metrics.

        Provides the following methods:
        - load_annotations(): Loads annotations to memory.
        - load_proposals(): Loads given proposals to memory.
        - get_imgs(): Gets desired image information.
        - get_anns(): Gets annotation information for a given image.
        - get_cats(): Gets all cats in the dataset.
        - get_ann_ids(): Gets annotation information by annotation ID.
        - get_img_ann_pairs(): Gets image-annotation pairs by image.
        - calculate_metrics(): Calculate validation metrics from proposals.
        - visualize_anns(): Visualizes annotations for an image using Pillow.

        :param ann_file: Path to the annotation file.
        :type ann_file: str
        """
        # Store class attributes
        self.ann_file = ann_file

        self.proposal_file = None
        self.proposals = None
        self.dataset_info = None
        self.img_info = None
        self.img_idx_lookup = dict()
        self.cat_info = None
        self.ann_info = None

    def __repr__(self):
        information = "<Oriented Bounding Box Dataset>\n"
        information += f"Ann file: {self.ann_file}\n"
        if self.dataset_info is not None:
            information += f"Num images: {len(self.img_info)}\n"
            information += f"Num anns: {len(self.ann_info)}\n"
            information += f"Num cats: {len(self.cat_info)}"
        else:
            information += "Annotations not yet loaded\n"
        if self.proposal_file:
            information += f"\nProposal file: {self.proposal_file}"
            information += f"\nNum proposals: {len(self.proposals)}>"
        else:
            information += "No proposals loaded."
        return information

    def __len__(self):
        return 0 if self.img_info is None else len(self.img_info)

    @staticmethod
    def _xor_args(m, n):
        only_one_arg = ((m is not None and n is None)
                        or (m is None and n is not None))
        assert only_one_arg, 'Only one type of request can be done at a time'

    def load_annotations(self):
        """Loads ann_info into memory.

        This is not done in the init in case a dataset is just to be initialized
        without actually loading it into memory yet.
        """
        print('loading ann_info...')

        # Set up timer
        start_time = time()
        with open(self.ann_file, 'r') as ann_file:
            data = json.load(ann_file)

        self.dataset_info = data['info']

        self.cat_info = {int(k): v for k, v in data['categories'].items()}
        self.ann_info = {int(k): v for k, v in data['annotations'].items()}

        self.img_info = data['images']

        for i, img in enumerate(data['images']):
            # lookup table used to figure out the index in self.img_info of
            # every image based on their img_id
            self.img_idx_lookup[int(img['id'])] = i

        self.img_info = data['images']

        print("done! t={:.2f}s".format(time() - start_time))

    def load_proposals(self, proposals_file):
        """Loads proposals into memory.

        This loads the generated proposals into memory so that metrics can be
        calculated on them.

        :param proposals_file: Path to the generated proposals file.
        :type proposals_file: str
        """
        assert self.img_info is not None, 'Annotations must be loaded before ' \
                                          'proposals'
        print('loading proposals...')
        start_time = time()
        with open(proposals_file, 'r') as p_file:
            props = json.load(p_file)['proposals']

        self.proposals = {i: [] for i in range(len(self.img_info))}

        for prop in props:
            prop_img_idx = self.img_idx_lookup[prop["img_id"]]
            self.proposals[prop_img_idx].append(prop)

        print('done! t={:.2f}s'.format(time() - start_time))

    def get_imgs(self, idxs=None, ids=None):
        """Gets the information of imgs at the given indices/ids.

        This only works with either idxs or ids, i.e. cannot get both the given
        idxs AND the given ids.

        :param idxs: The indices of the desired images.
        :param ids: The ids of the desired images
        :type idxs: list or tuple
        :type ids: list or tuple
        :returns: The information of the requested images as a list. Filenames
            will have had the data root as well as paths added to them.
        :rtype: list
        :raises: AssertionError if both idxs and ids are given.
        """
        self._xor_args(idxs, ids)

        if idxs is not None:
            assert isinstance(idxs, list), 'Given indices idxs must be a ' \
                                           'list or tuple'

            return [self.img_info[idx] for idx in idxs]
        else:
            assert isinstance(ids, list), 'Given ids must be a list or tuple'
            return [self.img_info[self.img_idx_lookup[i]] for i in ids]

    def get_anns(self, img_idx=None, img_id=None):
        """Gets the annotations for a given image by idx or img_id.

        :param img_idx: The index of the image.
        :param img_id: The img_id of the image.
        :type img_idx: int
        :type img_id: int
        :returns The list of annotation information (dict) for that image.
        :rtype: list
        """
        self._xor_args(img_idx, img_id)

        if img_idx:
            return self.get_ann_ids(self.img_info[img_idx]['ann_ids'])
        else:
            ann_ids = self.img_info[self.img_idx_lookup[img_id]]['ann_ids']
            return self.get_ann_ids(ann_ids)

    def get_cats(self):
        """Just returns the self.cat_info dictionary.

        :returns The category information of the currently loaded dataset.
        :rtype: dict
        """
        return self.cat_info

    def get_ann_ids(self, ann_ids):
        """Gets the annotation information for a given list of ann_ids.

        :param ann_ids: The annotation ids that are desired.
        :type ann_ids: list
        :returns: The annotation information as a dictionary with the key being
            the annotation img_id.
        :rtype: dict
        """
        assert isinstance(ann_ids, list), 'Given ann_ids must be a list or ' \
                                          'tuple'
        return {ann_id: self.ann_info[ann_id] for ann_id in ann_ids}

    def get_img_ann_pair(self, idxs=None, ids=None):
        """Gets the information and annotations at the given indices/ids.

        This only works with either idxs or ids, i.e. cannot get both the given
        idxs AND the given ids.

        :param idxs: The indices of the desired images.
        :param ids: The ids of the desired images
        :type idxs: list or tuple
        :type ids: list or tuple
        :returns: The information of the requested images as a tuple (list of
            image info, corresponding annotations)
        :rtype: tuple
        :raises: AssertionError if both idxs and ids are given.
        """
        self._xor_args(idxs, ids)

        imgs = self.get_imgs(idxs, ids)
        anns = [self.get_ann_ids(img['ann_ids']) for img in imgs]

        return imgs, anns

    def calculate_metrics(self):
        """Calculates proposed bounding box validation metrics.

        :returns A dictionary of calculated metric values.
        :rtype: dict
        """
        raise NotImplementedError

    def visualize(self,
                  img_idx=None,
                  img_id=None,
                  data_root=None,
                  img_dir=None,
                  seg_dir=None):
        """Uses PIL to visualize the ground truth labels of a given image.

        img_idx and img_id are mutually exclusive. Only one can be used at a
        time.

        :param img_idx: The index of the desired image.
        :param img_id: The id of the desired image.
        :param data_root: Path to the root data directory. If none is given, it
            is assumed to be the parent directory of the ann_file path.
        :param img_dir: Directory for the image files. For example, if the
            image files are in a subdirectory '[data_root]/imgs/[file_name]',
            then the img_dir is 'imgs'.
        :param seg_dir: Directory for the segmentation files. See img_dir
            for an example. If none is given, then an overlay of the
            segmentation will not be generated.
        :type img_idx: int
        :type img_id: int
        :type data_root: str or None
        :type img_dir: str or None
        :type seg_dir: str or None
        """
        # Since we can only visualize a single image at a time, we do i[0] so
        # that we don't have to deal with lists. get_img_ann_pair() returns a
        # tuple that's why we use list comprehension
        img_idx = [img_idx] if img_idx is not None else None
        img_id = [img_id] if img_id is not None else None
        img_info, ann_info = [i[0] for i in
                              self.get_img_ann_pair(idxs=img_idx, ids=img_id)]

        # Get the data_root from the ann_file path if it doesn't exist
        if data_root is None:
            data_root = osp.split(self.ann_file)[0]

        # Calculate the directories that the actual image and segmentations
        # are in
        img_dir = data_root if img_dir is None else osp.join(data_root, img_dir)

        # Get the actual image filepath and the segmentation filepath
        img_fp = osp.join(img_dir, img_info['filename'])
        print(f'Visualizing {img_fp}...')

        # Remember: PIL Images are in form (h, w, 3)
        img = Image.open(img_fp)

        if seg_dir is not None:
            seg_fp = osp.join(
                data_root,
                seg_dir,
                osp.splitext(img_info['filename'])[0] + '_seg.png'
            )
            seg = Image.open(seg_fp)

            # Here we overlay the segmentation on the original image using the
            # colorcet colors
            # First we need to get the new color values from colorcet
            colors = [ImageColor.getrgb(i) for i in cc.glasbey]
            colors = np.array(colors).reshape(768,).tolist()
            colors[0:3] = [0, 0, 0]   # Set background to black

            # Then put the palette
            seg.putpalette(colors)

            # Now the img and the segmentation can be composed together. Black
            # areas in the segmentation (i.e. background) are ignored
            seg_array = np.array(seg)
            mask = np.zeros_like(seg_array)
            mask[np.where(seg_array == 0)] = 255
            mask = Image.fromarray(mask, mode='L')

            img = Image.composite(img, seg.convert('RGB'), mask)
        draw = ImageDraw.Draw(img)

        # Now draw the bounding boxes onto the image
        for ann in ann_info.values():
            cat = self.cat_info[int(ann['cat_id'])]
            bbox = ann['bbox']
            # We use a mod to make sure we get a color within the possible
            # color range
            draw.polygon(bbox, outline='#00ff00')

            # Now draw the label below the bbox
            x0 = min(bbox[::2])
            y0 = max(bbox[1::2])

            x1, y1 = ImageFont.load_default().getsize(cat)
            x1 += x0 + 4
            y1 += y0 + 4
            draw.rectangle((x0, y0, x1, y1), fill='#303030')
            draw.text((x0 + 2, y0 + 2), cat, '#ffffff')

        img.show()

if __name__ == '__main__':
    a = OBBAnns('E:\Offline Docs\OBB\music\deepscores_oriented_train.json')
    a.load_annotations()
    for i in range(len(a)):
        a.visualize(img_idx=i, img_dir='images_png',
                    seg_dir='pix_annotations_png')
        # a.visualize(img_idx=i, img_dir='images_png')
        response = input('Press q to quit or enter to continue.')
        if response == 'q':
            break
