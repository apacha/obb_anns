"""Oriented Bounding Box Annotations.

Provides a toolkit to work with oriented bounding box ann_info.

Author:
    Yvan Satyawan <y_satyawan@hotmail.com>

Created on:
    February 19, 2020
"""
import json
from time import time
from datetime import datetime
import numpy as np
import os.path as osp
from PIL import Image, ImageColor, ImageDraw, ImageFont
import colorcet as cc
import pandas as pd
import polyiou


class OBBAnns:
    def __init__(self,
                 ann_file):
        """Toolkit to work with Oriented Bounding Boxes.

        Workflow is generally to initialize the class, load ann_info, run the
        training loop, then load proposals generated by the network, and finally
        to calculate the various metrics.

        Provides the following methods:
        - load_annotations(): Loads annotations to memory.
        - load_proposals(): Loads given proposals to memory.
        - get_imgs(): Gets desired image information.
        - get_anns(): Gets annotation information for a given image.
        - get_cats(): Gets all cats in the dataset.
        - get_ann_ids(): Gets annotation information by annotation ID.
        - get_img_ann_pairs(): Gets image-annotation pairs by image.
        - get_img_props(): Gets proposasls that belong to a given image.
        - calculate_metrics(): Calculate validation metrics from proposals.
        - visualize_anns(): Visualizes annotations for an image using Pillow.

        :param ann_file: Path to the annotation file.
        :type ann_file: str
        """
        # Store class attributes
        self.ann_file = ann_file

        self.proposal_file = None
        self.proposals = None
        self.dataset_info = None
        self.img_info = None
        self.img_idx_lookup = dict()
        self.cat_info = None
        self.ann_info = None

    def __repr__(self):
        information = "<Oriented Bounding Box Dataset>\n"
        information += f"Ann file: {self.ann_file}\n"
        if self.dataset_info is not None:
            information += f"Num images: {len(self.img_info)}\n"
            information += f"Num anns: {len(self.ann_info)}\n"
            information += f"Num cats: {len(self.cat_info)}"
        else:
            information += "Annotations not yet loaded\n"
        if self.proposal_file:
            information += f"\nProposal file: {self.proposal_file}"
            information += f"\nNum proposals: {len(self.proposals)}>"
        else:
            information += "No proposals loaded."
        return information

    def __len__(self):
        return 0 if self.img_info is None else len(self.img_info)

    @staticmethod
    def _xor_args(m, n):
        only_one_arg = ((m is not None and n is None)
                        or (m is None and n is not None))
        assert only_one_arg, 'Only one type of request can be done at a time'

    def load_annotations(self):
        """Loads ann_info into memory.

        This is not done in the init in case a dataset is just to be initialized
        without actually loading it into memory yet.
        """
        print('loading ann_info...')

        # Set up timer
        start_time = time()
        with open(self.ann_file, 'r') as ann_file:
            data = json.load(ann_file)

        self.dataset_info = data['info']

        self.cat_info = {int(k): v for k, v in data['categories'].items()}

        # Process annnotations
        ann_id = []
        anns = {'bbox': [],
                'cat_id': [],
                'area': [],
                'img_id': []}

        for k, v in data['annotations'].items():
            ann_id.append(int(k))
            anns['bbox'].append(v['bbox'])
            anns['cat_id'].append(int(v['cat_id']))
            anns['area'].append(v['area'])
            anns['img_id'].append(v['img_id'])
        self.ann_info = pd.DataFrame(anns, ann_id)

        self.img_info = data['images']

        for i, img in enumerate(data['images']):
            # lookup table used to figure out the index in self.img_info of
            # every image based on their img_id
            self.img_idx_lookup[int(img['id'])] = i

        self.img_info = data['images']

        print("done! t={:.2f}s".format(time() - start_time))

    def load_proposals(self, proposals_file):
        """Loads proposals into memory.

        This loads the generated proposals into memory so that metrics can be
        calculated on them.

        :param proposals_file: Path to the generated proposals file.
        :type proposals_file: str
        """
        assert self.img_info is not None, 'Annotations must be loaded before ' \
                                          'proposals'
        print('loading proposals...')
        start_time = time()
        with open(proposals_file, 'r') as p_file:
            props = json.load(p_file)['proposals']

        props_dict = {
            'bbox': [],
            'cat_id': [],
            'img_idx': []
        }

        for prop in props:
            prop_img_idx = self.img_idx_lookup[prop["img_id"]]
            props_dict['bbox'].append(prop['bbox'])
            props_dict['cat_id'].append(prop['cat_id'])
            props_dict['img_idx'].append(prop_img_idx)

        self.proposals = pd.DataFrame(props_dict)

        print('done! t={:.2f}s'.format(time() - start_time))

    def get_imgs(self, idxs=None, ids=None):
        """Gets the information of imgs at the given indices/ids.

        This only works with either idxs or ids, i.e. cannot get both the given
        idxs AND the given ids.

        :param idxs: The indices of the desired images.
        :param ids: The ids of the desired images
        :type idxs: list or tuple
        :type ids: list or tuple
        :returns: The information of the requested images as a list. Filenames
            will have had the data root as well as paths added to them.
        :rtype: list
        :raises: AssertionError if both idxs and ids are given.
        """
        self._xor_args(idxs, ids)

        if idxs is not None:
            assert isinstance(idxs, list), 'Given indices idxs must be a ' \
                                           'list or tuple'

            return [self.img_info[idx] for idx in idxs]
        else:
            assert isinstance(ids, list), 'Given ids must be a list or tuple'
            return [self.img_info[self.img_idx_lookup[i]] for i in ids]

    def get_anns(self, img_idx=None, img_id=None):
        """Gets the annotations for a given image by idx or img_id.

        :param img_idx: The index of the image.
        :param img_id: The img_id of the image.
        :type img_idx: int
        :type img_id: int
        :returns: Annotation information (dict) for that image with the key
            being the annotation ID and the value being the annotation
            information.
        :rtype: dict
        """
        self._xor_args(img_idx, img_id)

        if img_idx is not None:
            return self.get_ann_ids(self.img_info[img_idx]['ann_ids'])
        else:
            ann_ids = self.img_info[self.img_idx_lookup[img_id]]['ann_ids']
            return self.get_ann_ids(ann_ids)

    def get_cats(self):
        """Just returns the self.cat_info dictionary.

        :returns The category information of the currently loaded dataset.
        :rtype: dict
        """
        return self.cat_info

    def get_ann_ids(self, ann_ids):
        """Gets the annotation information for a given list of ann_ids.

        :param ann_ids: The annotation ids that are desired.
        :type ann_ids: list
        :returns: The annotation information requested.
        :rtype: pd.DataFrame
        """
        assert isinstance(ann_ids, list), 'Given ann_ids must be a list or ' \
                                          'tuple'
        return self.ann_info.loc[ann_ids, :]

    def get_img_ann_pair(self, idxs=None, ids=None):
        """Gets the information and annotations at the given indices/ids.

        This only works with either idxs or ids, i.e. cannot get both the given
        idxs AND the given ids.

        :param idxs: The indices of the desired images.
        :param ids: The ids of the desired images
        :type idxs: list or tuple
        :type ids: list or tuple
        :returns: The information of the requested images as a tuple (list of
            image info, corresponding annotations)
        :rtype: tuple
        :raises: AssertionError if both idxs and ids are given.
        """
        self._xor_args(idxs, ids)

        imgs = self.get_imgs(idxs, ids)
        anns = [self.get_ann_ids(img['ann_ids']) for img in imgs]

        return imgs, anns

    def get_img_props(self, idxs=None, ids=None):
        """Gets the proposals of an image at a given index or with a given ID.

        :param idxs: The indices of the desired images.
        :param ids: The ids of the desired images
        :type idxs: list or tuple
        :type ids: list or tuple
        :returns: The information of the requested images as a tuple (list of
            image info, corresponding annotations)
        :rtype: pd.DataFrame
        :raises: AssertionError if both idxs and ids are given.
        """
        self._xor_args(idxs, ids)

        # Proposals are checked by idx, not by id so we need to find their idxs
        if ids is not None:
            idxs = [self.img_idx_lookup[id] for id in ids]

        selector = self.proposals.img_idx.isin(idxs)
        return self.proposals[selector]

    def calculate_metrics(self):
        """Calculates proposed bounding box validation metrics.

        Calculates the AP with IoU = .50. Will return a mean AP as well
        as a class-wise AP.
        Also calculates the AR with 100 detections per image.

        :returns A dictionary of calculated metric values.
        :rtype: dict
        """
        def calculate_tpfp(detection, img_gt):
            """Calculates whether a detection is a true or false positive.

            :param pd.Series detection: Data frame for the detection
            :param pd.DataFrame img_gt: Ground truth for the image.
            :returns: ann_id of true positive bbox. If the detection is a
                false positive, then returns -1.
            :rtype: int
            """
            same_cat_gt = img_gt[img_gt['cat_id'] == detection['cat_id']]
            df = pd.DataFrame({
                'gt': same_cat_gt['bbox'],
                'det': [detection['bbox'] * len(same_cat_gt)]
            })

            def calculate_overlap(row):
                return polyiou.iou_poly(polyiou.VectorDouble(row['gt']),
                                        polyiou.VectorDouble(row['det']))

            overlaps = df.apply(calculate_overlap, 1)
            if overlaps.max() >= 0.5:
                # Means that there's at least one with an overlap. We take the
                # object with highest overlap.
                return overlaps.idxmax()
            else:
                return -1

        tp = []
        fp = []
        for img_idx in self.proposals:
            # For every image, look at each detection
            # img_props is a pandas DataFrame
            img_props = self.proposals[self.proposals['img_idx'] == img_idx]
            img_gt = self.get_anns(img_idx=img_idx)  # This is a dict of dicts

            # For all detections in an image, compare them to the ground truths
            for det_idx, det in img_props.iterrows():
                val = calculate_tpfp(det, img_gt)
                if val < 0:
                    fp.append(val)
                else:
                    tp.append(val)

        # Count number of False Positive (i.e. calculate_tpfp returned -1)
        tot_fp = len(fp)

        # Count number of ground truths with a corresponding detection
        # (True Positive)
        tp_set = set(tp)
        tot_tp = len(tp_set)

        # Count number of ground truths with multiple corresponding
        # detections (False Positive)
        tot_fp += len(tp) - len(tp_set)

        # Count number of ground truths without a corresponding detection
        # (False Negative)
        ann_gt_idxs = set([index for index, _ in self.ann_info.iterrows()])
        fn = []
        for i in list(tp_set):
            if i not in ann_gt_idxs:
                fn.append(i)

        precision = tot_tp / (tot_tp + tot_fp)
        recall = tot_tp / (tot_tp + len(fn))

        return {'precision': precision,
                'recall': recall}

    def _draw_bbox(self, draw, ann, color):
        """Draws the bounding box onto an image with a given color.

        :param ImageDraw.ImageDraw draw: ImageDraw object to draw with.
        :param dict ann: Annotation information dictionary of the current
            bounding box to draw.
        :param str color: Color to draw the bounding box in as a hex string,
            e.g. '#00ff00'
        :return: The drawn object.
        :rtype: ImageDraw.ImageDraw
        """
        cat = self.cat_info[int(ann['cat_id'])]
        bbox = ann['bbox']
        # We use a mod to make sure we get a color within the possible
        # color range
        draw.polygon(bbox, outline=color)

        # Now draw the label below the bbox
        x0 = min(bbox[::2])
        y0 = max(bbox[1::2])

        x1, y1 = ImageFont.load_default().getsize(cat)
        x1 += x0 + 4
        y1 += y0 + 4
        draw.rectangle((x0, y0, x1, y1), fill='#303030')
        draw.text((x0 + 2, y0 + 2), cat, '#ffffff')
        return draw

    def visualize(self,
                  img_idx=None,
                  img_id=None,
                  data_root=None,
                  img_dir=None,
                  seg_dir=None,
                  out_dir=None,
                  show=True):
        """Uses PIL to visualize the ground truth labels of a given image.

        img_idx and img_id are mutually exclusive. Only one can be used at a
        time. If proposals are currently loaded, then also visualizes the
        proposals.

        :param int img_idx: The index of the desired image.
        :param int img_id: The id of the desired image.
        :param Optional[str] data_root: Path to the root data directory. If
            none is given, it is assumed to be the parent directory of the
            ann_file path.
        :param Optional[str] img_dir: Directory for the image files. For
            example, if the image files are in a subdirectory
            '[data_root]/imgs/[file_name]', then the img_dir is 'imgs'.
        :param Optional[str] seg_dir: Directory for the segmentation files. See
            img_dir for an example. If none is given, then an overlay of the
            segmentation will not be generated.
        :param Optional[str] out_dir: Directory to save the visualizations in.
            If a directory is given, then the visualizations produced will also
            be saved.
        :param bool show: Whether or not to use pillow's show() method to
            visualize the image.
        """
        # Since we can only visualize a single image at a time, we do i[0] so
        # that we don't have to deal with lists. get_img_ann_pair() returns a
        # tuple that's why we use list comprehension
        img_idx = [img_idx] if img_idx is not None else None
        img_id = [img_id] if img_id is not None else None
        img_info, ann_info = [i[0] for i in
                              self.get_img_ann_pair(idxs=img_idx, ids=img_id)]

        # Get the data_root from the ann_file path if it doesn't exist
        if data_root is None:
            data_root = osp.split(self.ann_file)[0]

        # Calculate the directories that the actual image and segmentations
        # are in
        img_dir = data_root if img_dir is None else osp.join(data_root, img_dir)

        # Get the actual image filepath and the segmentation filepath
        img_fp = osp.join(img_dir, img_info['filename'])
        print(f'Visualizing {img_fp}...')

        # Remember: PIL Images are in form (h, w, 3)
        img = Image.open(img_fp)

        if seg_dir is not None:
            seg_fp = osp.join(
                data_root,
                seg_dir,
                osp.splitext(img_info['filename'])[0] + '_seg.png'
            )
            seg = Image.open(seg_fp)

            # Here we overlay the segmentation on the original image using the
            # colorcet colors
            # First we need to get the new color values from colorcet
            colors = [ImageColor.getrgb(i) for i in cc.glasbey]
            colors = np.array(colors).reshape(768,).tolist()
            colors[0:3] = [0, 0, 0]   # Set background to black

            # Then put the palette
            seg.putpalette(colors)

            # Now the img and the segmentation can be composed together. Black
            # areas in the segmentation (i.e. background) are ignored
            seg_array = np.array(seg)
            mask = np.zeros_like(seg_array)
            mask[np.where(seg_array == 0)] = 255
            mask = Image.fromarray(mask, mode='L')

            img = Image.composite(img, seg.convert('RGB'), mask)
        draw = ImageDraw.Draw(img)

        # Now draw the gt bounding boxes onto the image
        for ann in ann_info.to_dict('records'):
            draw = self._draw_bbox(draw, ann, '#00ff00')

        if self.proposals is not None:
            prop_info = self.get_img_props(idxs=img_idx, ids=img_id)

            for prop in prop_info.to_dict('records'):
                draw = self._draw_bbox(draw, prop, '#ff0000')

        if show:
            img.show()
        if out_dir is not None:
            img.save(osp.join(out_dir, datetime.now().strftime('%m-%d_%H%M%S')))
