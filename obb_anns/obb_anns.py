"""Oriented Bounding Box Annotations.

Provides a toolkit to work with oriented bounding box ann_info.

Author:
    Yvan Satyawan <y_satyawan@hotmail.com>

Created on:
    February 19, 2020
"""
import json
from time import time
import numpy as np
import os.path as osp
from PIL import Image
from matplotlib.path import Path


class OBBAnns:
    def __init__(self,
                 ann_file,
                 data_root=None,
                 img_prefix=None,
                 seg_prefix=None):
        """Toolkit to work with Oriented Bounding Boxes.

        Workflow is generally to initialize the class, load ann_info, run the
        training loop, then load proposals generated by the network, and finally
        to calculate the various metrics.

        Provides the following methods:
        - load_annotations()
        - load_proposals()
        - get_imgs()
        - get_anns()
        - get_cats()
        - get_ann_ids()
        - get_img_ann_pairs()
        - calculate_metrics()
        - visualize_anns()

        :param ann_file: Path to the annotation file.
        :param data_root: Path to the root data directory. If none is given, it
            is assumed to be the parent directory of the ann_file path.
        :param img_prefix: Prefix for the image files. For example, if the
            image files are in a subdirectory '[data_root]/imgs/[file_name]',
            then the img_prefix is 'imgs/'
        :param seg_prefix: Prefix for the segmentation files. See img_prefix
            for an example.
        :type ann_file: str
        :type data_root: str
        :type img_prefix: str
        :type seg_prefix: str
        """
        # Store class attributes
        self.ann_file = ann_file
        self.data_root = data_root if data_root else ''
        self.img_prefix = img_prefix if img_prefix else ''
        self.seg_prefix = seg_prefix if seg_prefix else ''

        self.proposal_file = None
        self.proposals = None
        self.dataset_info = None
        self.img_info = None
        self.img_idx_lookup = dict()
        self.cat_info = None
        self.ann_info = None

    def __repr__(self):
        information = "<Oriented Bounding Box Dataset.\n"
        information += f"Data root: {self.data_root}\n"
        information += f"Ann file: {self.ann_file}\n"
        if self.dataset_info is not None:
            information += f"Num images: {len(self.img_info)}\n"
            information += f"Num anns: {len(self.ann_info)}\n"
            information += f"Num cats: {len(self.cat_info)}"
        else:
            information += "Annotations not yet loaded\n"
        if self.proposal_file:
            information += f"\nProposal file: {self.proposal_file}"
            information += f"\nNum proposals: {len(self.proposals)}>"
        else:
            information += "No proposals loaded."
        return information

    def __len__(self):
        return 0 if self.img_info is None else len(self.img_info)

    @staticmethod
    def _xor_args(a, b):
        only_one_arg = ((a is not None and b is None)
                        or (a is None and b is not None))
        assert only_one_arg, 'Only one type of request can be done at a time'

    def load_annotations(self):
        """Loads ann_info into memory.

        This is not done in the init in case a dataset is just to be initialized
        without actually loading it into memory yet.
        """
        print('loading ann_info...')

        # Set up timer
        start_time = time()
        with open(self.ann_file, 'r') as ann_file:
            data = json.load(ann_file)

        self.dataset_info = data['info']

        self.cat_info = {int(k): v for k, v in data['categories'].items()}
        self.ann_info = {int(k): v for k, v in data['ann_info'].items()}

        self.img_info = data['images']
        for i, img in enumerate(data['images']):
            # lookup table used to figure out the index in self.img_info of
            # every image based on their img_id
            self.img_idx_lookup[int(img['img_id'])] = i

        self.img_info = data['images']

        print("done! t={:.2f}s".format(time() - start_time))

    def load_proposals(self, proposals_file):
        """Loads proposals into memory.

        This loads the generated proposals into memory so that metrics can be
        calculated on them.

        :param proposals_file: Path to the generated proposals file.
        :type proposals_file: str
        """
        assert self.img_info is not None, 'Annotations must be loaded before ' \
                                          'proposals'
        print('loading proposals...')
        start_time = time()
        with open(proposals_file, 'r') as p_file:
            props = json.load(p_file)['proposals']

        self.proposals = {i: [] for i in range(len(self.img_info))}

        for prop in props:
            prop_img_idx = self.img_idx_lookup[prop["img_id"]]
            self.proposals[prop_img_idx].append(prop)

        print('done! t={:.2f}s'.format(time() - start_time))

    def get_imgs(self, idxs=None, ids=None):
        """Gets the information of imgs at the given indices/ids.

        This only works with either idxs or ids, i.e. cannot get both the given
        idxs AND the given ids.

        :param idxs: The indices of the desired images.
        :param ids: The ids of the desired images
        :type idxs: list or tuple
        :type ids: list or tuple
        :returns: The information of the requested images as a list.
        :rtype: list
        :raises: AssertionError if both idxs and ids are given.
        """
        self._xor_args(idxs, ids)

        if idxs is not None:
            assert isinstance(idxs, list), 'Given indices idxs must be a ' \
                                           'list or tuple'
            return [self.img_info[idx] for idx in idxs]
        else:
            assert isinstance(ids, list), 'Given ids must be a list or tuple'
            return [self.img_info[self.img_idx_lookup[i]] for i in ids]

    def get_anns(self, img_idx=None, img_id=None):
        """Gets the annotations for a given image by idx or img_id.

        :param img_idx: The index of the image.
        :param img_id: The img_id of the image.
        :type img_idx: int
        :type img_id: int
        :returns The list of annotation information (dict) for that image.
        :rtype: list
        """
        self._xor_args(img_idx, img_id)

        if img_idx:
            return self.get_ann_ids(self.img_info[img_idx]['ann_ids'])
        else:
            ann_ids = self.img_info[self.img_idx_lookup[img_id]]['ann_ids']
            return self.get_ann_ids(ann_ids)

    def get_cats(self):
        """Just returns the self.cat_info dictionary.

        :returns The category information of the currently loaded dataset.
        :rtype: dict
        """
        return self.cat_info

    def get_ann_ids(self, ann_ids):
        """Gets the annotation information for a given list of ann_ids.

        :param ann_ids: The annotation ids that are desired.
        :type ann_ids: list
        :returns: The annotation information as a dictionary with the key being
            the annotation img_id.
        :rtype: dict
        """
        assert isinstance(ann_ids, list), 'Given ann_ids must be a list or ' \
                                          'tuple'
        return {self.ann_info[int(ann_id)] for ann_id in ann_ids}

    def get_img_ann_pair(self, idxs=None, ids=None):
        """Gets the information and annotations at the given indices/ids.

        This only works with either idxs or ids, i.e. cannot get both the given
        idxs AND the given ids.

        :param idxs: The indices of the desired images.
        :param ids: The ids of the desired images
        :type idxs: list or tuple
        :type ids: list or tuple
        :returns: The information of the requested images as a list.
        :rtype: list
        :raises: AssertionError if both idxs and ids are given.
        """
        self._xor_args(idxs, ids)

        imgs = self.get_imgs(idxs, ids)
        anns = [self.get_ann_ids(img['ann_ids']) for img in imgs]

        return imgs, anns

    def calculate_metrics(self):
        """Calculates proposed bounding box validation metrics.

        :returns A dictionary of calculated metric values.
        :rtype: dict
        """
        raise NotImplementedError

    def visualize(self, img_idx=None, img_id=None):
        """Uses PIL to visualize the ground truth labels of a given image.

        img_idx and img_id are mutually exclusive. Only one can be used at a
        time.

        :param img_idx: The index of the desired image.
        :param img_id: The id of the desired image.
        :type img_idx: int
        :type img_id: int
        """
        self._xor_args(img_idx, img_id)

        if img_id:
            img_idx = self.img_idx_lookup[img_id]

        img_info = self.img_info[img_idx]

        img = Image.open()

        # TODO Deal with data root and img prefixes